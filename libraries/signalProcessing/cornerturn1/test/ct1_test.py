# -*- coding: utf-8 -*-
#
# Copyright (c) 2022 CSIRO Space and Astronomy.
#
# Distributed under the terms of the CSIRO Open Source Software Licence
# Agreement. See LICENSE for more info.

"""
Standalone code to create configuration for the SKA low correlator corner turn 1 module
---------------------------------------------
Introduction:
Corner turn 1 (CT1) buffers packets and then plays them back in a known order.
Main functionality being tested here is the configuration and calculation of the delay polynomials.
This code reads in a yaml file and writes out configuration data for the yaml test case.
The configurationd data includes the polynomial coefficients.
----------------------------------------------
Configuration memory:
  The memory is organised into blocks of 80 bytes.
  Within that memory :
    words 0 to 9 : Config for virtual channel 0, buffer 0 (see below for specification of contents)
    words 10 to 19 : Config for virtual channel 1, buffer 0
    ...
    words 10230 to 10239 : Config for virtual channel 1023, first buffer
    words 10240 to 20479 : Config for all 1024 virtual channels, second buffer

  Polynomial data is stored in the memory as a block of 9 x 64bit words for each virtual channel:   
      word 0 = c0,
       ...  
      word 5 = c5,
               c0 to c5 are double precision floating point values for the delay polynomial :
               c0 + c1*t + c2 * t^2 + c3 * t^3 + c4 * t^4 + c5 * t^5
               Units for c0,.. c5 are ns/s^k for k=0,1,..5
      word 6 = Sky frequency in GHz
               Used to convert the delay (in ns) to a phase rotation.
               (delay in ns) * (sky frequency in GHz) = # of rotations
               From the Matlab code:
                % Phase Rotation
                %  The sampling point is (DelayOffset_all * Ts)*1e-9 ns
                %  then multiply by the center frequency (CF) to get the number of rotations.
                %
                %  The number of cycles of the center frequency per output sample is not an integer due to the oversampling of the LFAA data.
                %  For example, for coarse channel 65, the center frequency is 65 * 781250 Hz = 50781250 Hz.
                %  50781250 Hz = a period of 1/50781250 = 19.692 ns. The sampling period for the LFAA data is 1080 ns, so 
                %  a signal at the center of channel 65 goes through 1080/19.692 = 54.8438 cycles. 
                %  So a delay which is an integer number of LFAA samples still requires a phase shift to be correct.
                resampled = resampled .* exp(1i * 2*pi*DelayOffset_all * Ts * 1e-9 * CF);
                # Note : DelayOffset_all = delay in number of samples (of period Ts)
                #        Ts = sample period in ns (i.e. 1080 for SPS data)
                #        CF = channel center frequency in Hz, e.g. 65 * 781250 = 50781250 for the first SPS channel
                #        - The value [Ts * 1e-9 * CF] is the value stored here.

      word 7 = buf_offset_seconds : seconds from the polynomial epoch to the start of the integration period, as a double precision value 
              
      word 8 = double precision offset in ns for the second polarisation (relative to the first polarisation).   

      word 9 = Validity time
               - bits 31:0 = buf_integration : Integration period at which the polynomial becomes valid. Integration period
                             is in units of 0.84934656 seconds, i.e. units of (384 SPS packets) 
               - bit 32 = Entry is valid.

"""

# import matplotlib.pyplot as plt
import argparse
import numpy as np
import yaml
import typing
import sys
import filterbank

# 31 FIR tap deripple filter, for the SPS 18-tap filter 
c_deripple = np.array([5,-7,12,-21,31,169,-676,504,-833,1007,-1243,1442,-1620,1756,-1842,68166,-1842,1756,-1620,1442,-1243,1007,-833,504,-676,169,31,-21,12,-7,5])

# 49 tap FIR deripple filters
c_fir_taps = 49
c_deripple0 = np.array([0,  0, 0,   0,  0,   0,  0,   0,  0,    0,   0,    0,   0,    0,   0,     0,    0,     0,    0,     0,    0,     0,    0,     0,  65536,     0,    0,     0,    0,     0,    0,     0,    0,     0,    0,    0,   0,    0,   0,    0,  0,   0,  0,   0,  0,   0, 0,  0,  0])
c_deripple1 = np.array([3, -6, 10, -16, 24, -34, 46, -61, 98, -128, 173, -229, 300, -387, 488,  -621, 1881, -1705, 2110, -2498, 2861, -3172, 3411, -3562, 69172, -3562, 3411, -3172, 2861, -2498, 2110, -1705, 1881,  -621,  488, -387, 300, -229, 173, -128, 98, -61, 46, -34, 24, -16, 10, -6, 3])
c_deripple2 = np.array([1, -2, 4,   -7, 12, -21, 36, -51, 78, -111, 155, -213, 284, -362, 652, -1263, 1209, -1653, 1944, -2288, 2583, -2843, 3040, -3165, 68751, -3165, 3040, -2843, 2583, -2288, 1944, -1653, 1209, -1263,  652, -362, 284, -213, 155, -111, 78, -51, 36, -21, 12,  -7,  4, -2, 1])

# Alias power used in RFI calculation
# Generated by the matlab code RFI_analysis.m in the filterbanks directory
RFI_analysis = np.array([ 1, 1, 1, 1, 1, 1, 1, 1,
                          1, 1, 1, 1, 1, 2, 5, 9, 
                          12,      10,      3,      6,      46,     137,    254,     318,
                          250,     81,      36,     464,    1551,   2973,   3841,    3264,
                          1391,    163,     2727,   11136,  23481,  33001,  31521,   17136,
                          2243,    15671,   94095,  263770, 520726, 821207, 1090759, 1250784,
                          1250949, 1091201, 821791, 521291, 264194, 94333,  15749,   2230,
                          17100,   31504,   33011,  23505,  11157,  2738,   163,     1387,
                          3261,    3842,    2976,   1554,   465,    36,     81,      250,
                          318,     254,     137,    46,     6,      2,      10,      12,
                          9,       5,       2,      1,      1,      1,      1,       1,
                          1,       1,       1,      1,      1,      1,      1,       1])


def command_line_args():
    parser = argparse.ArgumentParser(description="Correlator CT1 polynomial configuration generator")
    parser.add_argument(
        "-d",
        "--data",
        type=argparse.FileType(mode="wt"),
        help="File to write configuration data to, only writes non-zero data",
        required=False,
    )
    parser.add_argument(
        "-t",
        "--tbdata",
        type=argparse.FileType(mode="rt"),
        help="File to read CT1 output from",
        required=False,
    )
    parser.add_argument(
        "-f",
        "--fbdata",
        type=argparse.FileType(mode="rt"),
        help="File to read the filterbank output from",
        required=False,
    )
    parser.add_argument(
        "-g",
        "--filterbank-taps",
        help="text file with filterbank taps",
        required=True,
    )
    
    #parser.add_argument("-H0", "--HBM0", help="HBM buffer 0 data from firmware to check",
    #                    type=argparse.FileType(mode="r"))
    #parser.add_argument("-f", "--filter", help="Interpolation filter taps", type=argparse.FileType(mode="r"))
    parser.add_argument(
        "configuration",
        help="Test Configuration (YAML)",
        type=argparse.FileType(mode="r"),
    )
    return parser.parse_args()

def parse_config(file: typing.IO) -> typing.Dict:
    """
    Reads configuration YAML file, checks if required values are present.

    :param file: The YAML file object
    :return: Settings dict, guaranteed to contain the keys specified in required_keys
    :raises AssertionError: if required key(s) are missing
    """
    config = yaml.safe_load(file)

    required_keys = {"polynomials"}
    assert config.keys() >= required_keys, "Configuration YAML missing required key(s)"
    
    """
    print("\n??\tSettings:")
    for parameter, value in config.items():
        if parameter == "polynomials":
            print("\tpolynomials:")
            for n, src_cfg in config["polynomials"].items():
                print(f"\t  {n}:")
                for src_param, src_val in src_cfg.items():
                    print(f"\t    {src_param}: {src_val}")
        else:
            print(f"\t{parameter}: {value}")
    """
    
    return config


def ct1_config(config):
    """
    :param config: configuration data as read from the yaml file,
    config["polynomials"][source number]["virtual_channel","poly0","sky_freq0","buf_offset0","Ypol_offset0","integration0","valid0",
        "poly1","sky_freq1","buf_offset1","Ypol_offset1","integration1","valid1",]
    :return: numpy array of uint32 to be loaded into the CT1 polynomial configuration memory.
    """
    # keys start from 0, so add 1 to get total sources
    total_sources = np.max(list(config["polynomials"].keys())) + 1
    print(f"total_sources = {total_sources}")
    # each source has 2*80 bytes of configuration data
    # store as 4-byte integers so 40 entries per source
    config_array_buf0 = np.zeros(1024*20, np.uint32)
    config_array_buf1 = np.zeros(1024*20, np.uint32)
    poly_coefficients0 = np.zeros(6, np.float64)
    poly_coefficients1 = np.zeros(6, np.float64)
    vc_max = 0
    RFI_thresholds = np.zeros(1024, np.uint32)
    for n, src_cfg in config["polynomials"].items():
        vc = src_cfg["virtual_channel"]
        if vc > vc_max :
            vc_max = vc
        for c_index in range(6):
            poly_coefficients0[c_index] = np.float64(src_cfg["poly0"][c_index])
            poly_coefficients1[c_index] = np.float64(src_cfg["poly1"][c_index])
        RFI_thresholds[vc] = src_cfg["RFI_threshold"]
        config_array_buf0[(vc*20):(vc*20+12)] = np.frombuffer(poly_coefficients0.tobytes(), dtype=np.uint32)
        config_array_buf0[(vc*20+12):(vc*20+14)] = np.frombuffer(np.float64(src_cfg["sky_freq0"]).tobytes(), dtype=np.uint32)

        config_array_buf1[(vc*20):(vc*20+12)] = np.frombuffer(poly_coefficients1.tobytes(), dtype=np.uint32)
        config_array_buf1[(vc*20+12):(vc*20+14)] = np.frombuffer(np.float64(src_cfg["sky_freq1"]).tobytes(), dtype=np.uint32)

        # buf_offset_seconds : seconds from the polynomial epoch to the start of the integration period, as a double precision value 
        config_array_buf0[(vc*20+14):(vc*20+16)] = np.frombuffer(np.float64(src_cfg["buf_offset0"]).tobytes(), dtype=np.uint32)
        config_array_buf1[(vc*20+14):(vc*20+16)] = np.frombuffer(np.float64(src_cfg["buf_offset1"]).tobytes(), dtype=np.uint32)
        
        # word 8 = double precision offset in ns for the second polarisation (relative to the first polarisation).   
        config_array_buf0[(vc*20+16):(vc*20+18)] = np.frombuffer(np.float64(src_cfg["Ypol_offset0"]).tobytes(), dtype=np.uint32)
        config_array_buf1[(vc*20+16):(vc*20+18)] = np.frombuffer(np.float64(src_cfg["Ypol_offset1"]).tobytes(), dtype=np.uint32)
        
        # word 9 = Validity time
        # bits 31:0 = buf_integration : Integration period at which the polynomial becomes valid. Integration period
        #                     is in units of 0.84934656 seconds, i.e. units of (384 SPS packets) 
        # bit 32 = Entry is valid.
        config_array_buf0[vc*20+18] = np.frombuffer(np.int32(src_cfg["integration0"]).tobytes(), dtype=np.uint32)
        config_array_buf1[vc*20+18] = np.frombuffer(np.int32(src_cfg["integration1"]).tobytes(), dtype=np.uint32)
        
        config_array_buf0[vc*20+19] = np.frombuffer(np.int32(src_cfg["valid0"]).tobytes(), dtype=np.uint32)
        config_array_buf1[vc*20+19] = np.frombuffer(np.int32(src_cfg["valid1"]).tobytes(), dtype=np.uint32)
        
    return (config_array_buf0, config_array_buf1, RFI_thresholds, vc_max)

def conv_signed_16bit(din):
    if din > 32767:
        return (din - 65536)
    else:
        return (din)

def conv_signed_8bit(din):
    if din > 127:
        return (din - 256)
    else:
        return (din)

def get_tb_fb_data(tb_file, virtual_channels):
    # Load data saved by the testbench at the output of the filterbank
    # File format : text
    #  Each packet is 3457 lines
    # first line is meta data : 
    #  1 integration ct_frame vc0 vc1 vc2 vc3 bad_poly last_channel demap_table_select
    # Remaining 3456 lines are packet data :
    #  5  vc0_pol0_re vc0_pol0_im vc0_pol1_re vc0_pol1_im vc1... vc2... vc3...
    print("Loading data at the filterbank output")
    first_integration_set = False
    first_integration = 0
    integrations = 2
    # Number of packets received for each integration, frame and virtual channel
    packet_count = np.zeros((integrations,3,virtual_channels),dtype=np.int32)
    # meta data : [integration, frame, packet, vc, bad_poly/last_channel/demap_table_select]
    # 64 packets per frame
    meta_data = np.zeros((integrations,3,64,virtual_channels,3),dtype = np.int64)
    # data [integration, frame, packet, vc, Hre/Him/Vre/Vim, fine_channel]
    sim_fbout = np.zeros((integrations,3,64,virtual_channels,4,3456), dtype = np.int32)
    vc_list = np.zeros(4,dtype = np.int32)
    first_line = True
    linecount = 0
    
    for line in tb_file:
        dval = line.split()
        dint = [int(di,16) for di in dval]
        if first_line:
            print("filterbank output dint : ")
            print(dint)
        if dint[0] == 1:  # line of meta data at the start of the packet
            if not first_integration_set:
                first_integration_set = True
                first_integration = dint[1]
            integration = dint[1] - first_integration
            frame = dint[2]
            vc_list[0] = dint[3]
            vc_list[1] = dint[4]
            vc_list[2] = dint[5]
            vc_list[3] = dint[6]
            for vc_count in range(4):
                # same meta data for groups of 4 virtual channels
                meta_data[integration, frame, packet_count[integration, frame, vc_list[vc_count]], vc_list[vc_count], 0] = dint[7]
                meta_data[integration, frame, packet_count[integration, frame, vc_list[vc_count]], vc_list[vc_count], 1] = dint[8]
                meta_data[integration, frame, packet_count[integration, frame, vc_list[vc_count]], vc_list[vc_count], 2] = dint[9]
                packet_count[integration, frame, vc_list[vc_count]] = packet_count[integration, frame, vc_list[vc_count]] + 1
                dcount = 0
        else:
            # dint[0] == 5, the data part
            for vc_count in range(4):   # 4 virtual channels per line
                for component in range(4): # 4 components (H pol re, H pol im, V pol re, V pol im)
                    #if (dcount > 3455):
                    #    print(f"line {linecount} in the filterbank output")
                    #    print(f"integration = {integration}, frame = {frame}, vclist = {vc_list}, dcount= {dcount}")
                    #    print(dint)
                    first_line = False
                    sim_fbout[integration, frame, packet_count[integration,frame,vc_list[vc_count]] - 1, vc_list[vc_count], component, dcount] = conv_signed_8bit(dint[1 + vc_count * 4 + component])
            dcount = dcount + 1                    
        linecount += 1
    return (meta_data, sim_fbout, packet_count)
            
            
def get_tb_data(tb_file, virtual_channels):
    # Load data saved by the testbench at the output of corner turn 1
    # File Format : text
    #   - 4 lines of meta data, one per channel
    #                  <1-4> HdeltaP, HoffsetP, VdeltaP, VoffsetP, integration, frame, virtual channel
    # array element:    0       1       2         3          4           5        6          7 
    #   - 4096 lines of data   
    #      5 <re Hpol> <im Hpol> <re Vpol> <im Vpol> ... (x4 for 4 virtual channels)
    print("Loading data at the output of corner turn 1")
    first_integration_set = False
    first_integration = 0
    # Number of packets received for each integration, frame and virtual channel
    packet_count = np.zeros((10,3,virtual_channels),dtype=np.int32)
    # meta data : [integration, frame, packet, vc, hdelta/Hoffset/Vdelta/Voffset]
    # 75 packets = 11 preload + 64 per frame
    meta_data = np.zeros((10,3,75,virtual_channels,4),dtype = np.int64)
    # data [integration,frame,packet,vc,Hre/Him/Vre/Vim,sample]
    data_data = np.zeros((10,3,75,virtual_channels,4,4096), dtype = np.int32)
    vc_list = np.zeros(4,dtype = np.int32)
    for line in tb_file:
        dval = line.split()
        dint = [int(di,16) for di in dval]
        if dint[0] == 1:
            if not first_integration_set:
                first_integration_set = True
                first_integration = dint[5]
        if (dint[0] == 1 or dint[0] == 2 or dint[0] == 3 or dint[0] == 4):
            integration = dint[5] - first_integration
            frame = dint[6]
            vc = dint[7]
            vc_list[dint[0]-1] = vc
            # meta data indexed by [integration, frame (0,1,2), packet (), vc, parameter]
            #  where parameter : 0 = HdeltaP, 1 = HoffsetP, 2 = VdeltaP, 3 = VoffsetP
            meta_data[integration, frame, packet_count[integration, frame, vc], vc, 0] = dint[1]
            meta_data[integration, frame, packet_count[integration, frame, vc], vc, 1] = dint[2]
            meta_data[integration, frame, packet_count[integration, frame, vc], vc, 2] = dint[3]
            meta_data[integration, frame, packet_count[integration, frame, vc], vc, 3] = dint[4]
            packet_count[integration, frame, vc] = packet_count[integration, frame, vc] + 1
            dcount = 0
        else:
            # dint[0] == 5, the data part
            # data_data index by [integration, frame, packet_count, vc, Hre/Him/Vre/Vim, sample
            #if dcount == 4095:
            #    print(f"Read last element of testbench packet : integration {integration}, frame = {frame}, packet_count = {packet_count[integration,frame,vc]}")
            if dcount > 4095:
                print(f"!!!!! Too many samples in the packet to the filterbank, dcount = {dcount}")
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[0], 0, dcount] = conv_signed_16bit(dint[1])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[0], 1, dcount] = conv_signed_16bit(dint[2])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[0], 2, dcount] = conv_signed_16bit(dint[3])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[0], 3, dcount] = conv_signed_16bit(dint[4])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[1], 0, dcount] = conv_signed_16bit(dint[5])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[1], 1, dcount] = conv_signed_16bit(dint[6])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[1], 2, dcount] = conv_signed_16bit(dint[7])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[1], 3, dcount] = conv_signed_16bit(dint[8])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[2],0, dcount] = conv_signed_16bit(dint[9])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[2],1, dcount] = conv_signed_16bit(dint[10])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[2],2, dcount] = conv_signed_16bit(dint[11])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[2],3, dcount] = conv_signed_16bit(dint[12])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[3],0, dcount] = conv_signed_16bit(dint[13])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[3],1, dcount] = conv_signed_16bit(dint[14])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[3],2, dcount] = conv_signed_16bit(dint[15])
            data_data[integration, frame, packet_count[integration,frame,vc] - 1, vc_list[3],3, dcount] = conv_signed_16bit(dint[16])
            dcount = dcount + 1
    
    return (meta_data, data_data, packet_count)

def fix_8bit_rfi(din):
    # take values in the range 0 to 255 and convert to integers, with
    # x=128 = 0x80 = RFI => 0
    # x>128 = negative => x-256
    # x<128 = positive => x
    dout = din
    flagged = np.zeros(din.shape)
    for n1 in range(din.size):
        if (din[n1] == 128):
            dout[n1] = 0
            flagged[n1] = 1
        elif din[n1] > 128:
            dout[n1] = din[n1] - 256
        else:
            dout[n1] = din[n1]
    return (dout, flagged)

def rfi_diff(a,b):
    # compare values after RFI marking, allowing for small differences
    if (a == -128) or (b == -128):
        # If either value is flagged RFI, compare absolute values, so e.g. -128 is close to 127
        a_test = np.abs(a)
        b_test = np.abs(b)
    else:
        a_test = a
        b_test = b
    return np.abs(a_test - b_test)

def main():
    # Read command-line arguments
    args = command_line_args()
    config = parse_config(args.configuration)
    # convert config into a data file to load into the firmware
    (cfg_array0, cfg_array1, RFI_thresholds, vc_max) = ct1_config(config)
    # Write to file.
    # Writes are in blocks of 20 words, preceded by the address to write to.
    total_blocks = vc_max+1
    for b in range(total_blocks):
        # 80 bytes per block
        block_addr = b*80
        block_addr2 = 1024*80 + b*80
        non_zero = np.any(cfg_array0[b*20:(b*20+20)])
        if non_zero:
            args.data.write(f"[{block_addr:08x}]\n")
            for n in range(20):
                args.data.write(f"{cfg_array0[b*20+n]:08x}\n")
            args.data.write(f"[{block_addr2:08x}]\n")
            for n in range(20):
                args.data.write(f"{cfg_array1[b*20+n]:08x}\n")
    # write the RFI thresholds to the same file
    # RFI thresholds are (up to) 1024 words, starting at byte address 196608 = x30000 (or 4-byte word address 0xC000)
    RFI_addr = 196608
    args.data.write(f"[{RFI_addr:08x}]\n")
    for b in range(20 * ((vc_max+20)//20)):   # Use a multiple of 20 words to make the vhdl testbench happy
        args.data.write(f"{RFI_thresholds[b]:08x}\n")
    
    # Get the output of the simulation
    if args.tbdata:
        (meta_data, data_data, packet_count) = get_tb_data(args.tbdata, total_blocks)
        tb_valid = True
    else:
        tb_valid = False
    
    if args.fbdata:
        (sim_fb_meta, sim_fb_data, sim_fb_packet_count) = get_tb_fb_data(args.fbdata, total_blocks)
        filterbank_fir_taps = open(f"{args.filterbank_taps}", "rt")
        fb = filterbank.PolyphaseFilterBank(filterbank_fir_taps)
        sim_fb_valid = True
        # sim_fb_data[integration_offset, frame_in_integration, fb_pkt_out, vc, 0, fine_freq]
        print("first fine frequency for first 4 virtual channels")
        print(sim_fb_data[0,0,0,0,0,0])
        print(sim_fb_data[0,0,0,1,0,0])
        print(sim_fb_data[0,0,0,2,0,0])
        print(sim_fb_data[0,0,0,3,0,0])
    else:
        sim_fb_valid = False
    
    # Calculate the expected delays for each virtual channel
    integration_start = config["integration_start"]
    sim_frames = config["sim_frames"]
    if config["ripple"] == 0:
        deripple = c_deripple0
    elif config["ripple"] == 1:
        deripple = c_deripple1
    elif config["ripple"] == 2:
        deripple = c_deripple2
    else:
        print("!!! ripple selection error")
        sys.exit()
    
    data_mismatch = 0
    data_match = 0
    meta_match = 0
    meta_mismatch = 0
    fd_mismatch = 0
    fd_match = 0
    for frame in range(sim_frames):
        integration_offset = frame // 3
        integration = integration_start + integration_offset
        frame_in_integration = frame - integration_offset * 3
        for vc in range(vc_max + 1):
            # Find the config entry for this virtual channel
            vc_found = False
            for n, src_cfg in config["polynomials"].items():
                this_vc = src_cfg["virtual_channel"]
                if vc == this_vc:
                    if vc_found == True:
                        print(f"!!!! Multiple instances of virtual channel {this_vc} in config yaml file")
                    vc_found = True
                    cfg_n = n
            if  not vc_found:
                print(f"!!! frame {frame}, No specification for virtual channel {vc}")
            else:
                src_cfg = config["polynomials"][vc]
                if (src_cfg["valid0"]==1) and (integration >= src_cfg["integration0"]):
                    cfg0_valid = True
                else:
                    cfg0_valid = False
                if (src_cfg["valid1"]==1) and (integration >= src_cfg["integration1"]):
                    cfg1_valid = True
                else:
                    cfg1_valid = False
               
                if cfg1_valid and ((not cfg0_valid) or (src_cfg["integration1"] > src_cfg["integration0"])):
                    # select second configuration
                    poly = src_cfg["poly1"]
                    # sky frequency in GHz
                    sky_freq = src_cfg["sky_freq1"]
                    # Validity time : 32 bit buf_integration: Integration period at which the polynomial becomes valid.
                    integration_validity = src_cfg["integration1"]
                    # seconds from the polynomial epoch to the start of the integration period, as a double precision value
                    buf_offset = src_cfg["buf_offset1"]
                    # Double precision offset in ns for the second polarisation (relative to the first polarisation). 
                    Ypol_offset = src_cfg["Ypol_offset1"]
                else:
                    if (not cfg0_valid) and (not cfg1_valid):
                        print(f"No valid polynomials, ")
                    # select first configuration
                    poly = src_cfg["poly0"]
                    sky_freq = src_cfg["sky_freq0"]
                    integration_validity = src_cfg["integration0"]
                    buf_offset = src_cfg["buf_offset0"]
                    Ypol_offset = src_cfg["Ypol_offset0"]
                
                for packet in range(75):
                    # 75 packets produced by CT1 for each frame
                    # 11 preload packets, then 64 packets.
                    # Time in seconds in the polynomial
                    t = buf_offset + frame_in_integration * 0.283115520 + (integration - integration_validity) * 0.849346560
                    # Each packet is 4.4ms
                    if packet > 10:
                        t = t + (packet-11) * 0.00442368
                    delay_Xpol = poly[0] + poly[1]*t + poly[2]*(t**2) + poly[3]*(t**3) + poly[4]*(t**4) + poly[5]*(t**5)
                    delay_Ypol = delay_Xpol + Ypol_offset
                    delay_samples_Xpol = delay_Xpol/1080.0
                    delay_samples_Ypol = delay_Ypol/1080.0
                    if packet == 0:
                        coarse_delay = np.int32(np.floor(delay_samples_Xpol))
                    fine_delay_Xpol = delay_samples_Xpol - coarse_delay
                    fine_delay_Ypol = delay_samples_Ypol - coarse_delay
                    if (fine_delay_Xpol >= 0):
                        fine_delay_Xpol = np.int64(np.floor(fine_delay_Xpol * 16384*65536))
                    else:
                        fine_delay_Xpol = 65536*65536 - np.int64(np.floor(-fine_delay_Xpol*16384*65536))
                    if (fine_delay_Ypol >= 0):
                        fine_delay_Ypol = np.int64(np.floor(fine_delay_Ypol * 16384*65536))
                    else:
                        fine_delay_Ypol = 65536*65536 - np.int64(np.floor(-fine_delay_Ypol*16384*65536))
                    phase_X = delay_Xpol * sky_freq
                    phase_Y = delay_Ypol * sky_freq
                    phase_X = np.int64(np.floor(65536*65536 * (phase_X - np.floor(phase_X))))
                    phase_Y = np.int64(np.floor(65536*65536 * (phase_Y - np.floor(phase_Y))))
                    
                    # print(f"VC = {vc}, (int,frame,packet) = ({integration},{frame_in_integration},{packet}) coarse = {coarse_delay}, fine X = {fine_delay_Xpol}, fine Y = {fine_delay_Ypol}, phase X = {phase_X}, phase_Y = {phase_Y}")
                    if tb_valid:
                        # Compare with the data loaded from the testbench
                        # Calculate which sample this packet should start at
                        # Simulation puts the sample number in the data, where the 
                        # sample number is the number of samples since the epoch
                        first_sample = integration * 192 * 4096 + frame_in_integration * 64*4096 + packet*4096 - 6*4096 - coarse_delay
                        
                        # create the expected value
                        # Apply the deripple FIR filter = c_deripple = [5,-7,12,-21,31,169,-676,504,-833,1007,-1243,1442,-1620,1756,-1842,68166,-1842,1756,-1620,1442,-1243,1007,-833,504,-676,169,31,-21,12,-7,5]
                        # to the expected data
                        # 
                        # Get the expected samples that the deripple filter is applied to. Initialisation of the FIR 31 tap filter needs:
                        #  - 15 samples extra at the front
                        #  - total 30 samples extra
                        # Likewise 49 tap FIR filter needs 24 extra sample at the front, 48 extra altogether.
                        first_sample = integration * 192 * 4096 + frame_in_integration * 64*4096 + packet*4096 - 6*4096 - coarse_delay - c_fir_taps//2
                        packet_samples = np.arange(first_sample,first_sample+4096+(c_fir_taps - 1))
                        (expected_packet_Xre, Xre_flagged) = fix_8bit_rfi(packet_samples % 256)
                        (expected_packet_Xim, Xim_flagged) = fix_8bit_rfi((packet_samples // 256) % 256)
                        (expected_packet_Yre, Yre_flagged) = fix_8bit_rfi((packet_samples // 65536) % 256)
                        (expected_packet_Yim, Yim_flagged) = fix_8bit_rfi(vc * np.ones(4096+c_fir_taps - 1))   # Yim is fixed to the virtual channel in the testbench
                        any_flagged = Xre_flagged + Xim_flagged + Yre_flagged + Yim_flagged
                        #if (packet == 14) and (vc == 5):
                        #    print(f"dbg check : VC = {vc}, (int,frame,packet) = ({integration},{frame_in_integration},{packet}) coarse = {coarse_delay}")
                        #    print(f"First 8 packet samples = {packet_samples[24:32]}")
                        #    print(f"{expected_packet_Xre[24]},{expected_packet_Xim[24]},{expected_packet_Yre[24]},{expected_packet_Yim[24]}")
                        #    print(f"{Xre_flagged[24:32]},{Xim_flagged[24:32]},{Yre_flagged[24:32]},{Yim_flagged[24:32]}")
                        
                        for sample in range(4096):
                            Xre = data_data[integration_offset,frame_in_integration,packet,vc,0,sample]
                            Xim = data_data[integration_offset,frame_in_integration,packet,vc,1,sample]
                            Yre = data_data[integration_offset,frame_in_integration,packet,vc,2,sample]
                            Yim = data_data[integration_offset,frame_in_integration,packet,vc,3,sample]
                            
                            # Apply the deripple filter to the expected values
                            expected_Xre = 0
                            expected_Xim = 0
                            expected_Yre = 0
                            expected_Yim = 0
                            for FIR_tap in range(c_fir_taps):
                                expected_Xre = expected_Xre + deripple[FIR_tap] * expected_packet_Xre[sample + FIR_tap]
                                expected_Xim = expected_Xim + deripple[FIR_tap] * expected_packet_Xim[sample + FIR_tap]
                                expected_Yre = expected_Yre + deripple[FIR_tap] * expected_packet_Yre[sample + FIR_tap]
                                expected_Yim = expected_Yim + deripple[FIR_tap] * expected_packet_Yim[sample + FIR_tap]
                                #if (sample == 0) and (packet == 0) and (vc == 0):
                                #    print(f"FIR {FIR_tap}, FIR tap = {c_deripple[FIR_tap]}, data = {expected_packet_Xre[sample + FIR_tap]}, cumulative sum = {expected_Xre}")
                            
                            if any_flagged[sample + c_fir_taps//2]:
                                expected_Xre = -32768
                                expected_Xim = -32768
                                expected_Yre = -32768
                                expected_Yim = -32768
                            else:
                                # divide by 512, convergent round to even
                                expected_Xre = np.round(expected_Xre / 512)
                                expected_Xim = np.round(expected_Xim / 512)
                                expected_Yre = np.round(expected_Yre / 512)
                                expected_Yim = np.round(expected_Yim / 512)
                            if (expected_Xre != Xre) or (expected_Xim != Xim) or (expected_Yre != Yre) or (expected_Yim != Yim):
                                if data_mismatch < 20:
                                    print(f"Bad sample : VC = {vc}, (int,frame,packet) = ({integration},{frame_in_integration},{packet}) coarse = {coarse_delay}")
                                    print(f"   At sample {sample}, expected ({expected_Xre},{expected_Xim},{expected_Yre},{expected_Yim}), testbench = ({Xre},{Xim},{Yre},{Yim})")
                                data_mismatch += 1
                            else:
                                data_match += 1 
                        # Compare fine delays
                        fine_delay_Xpol_tb = meta_data[integration_offset,frame_in_integration,packet,vc,0]
                        phase_X_tb = meta_data[integration_offset,frame_in_integration,packet,vc,1]
                        fine_delay_Ypol_tb = meta_data[integration_offset,frame_in_integration,packet,vc,2]
                        phase_Y_tb = meta_data[integration_offset,frame_in_integration,packet,vc,3]
                        #if ((fine_delay_Xpol_tb != fine_delay_Xpol) or (fine_delay_Ypol_tb != fine_delay_Ypol) or (phase_X_tb != phase_X) or (phase_Y_tb != phase_Y)):
                        if ((np.abs(fine_delay_Xpol_tb - fine_delay_Xpol) > 1) or (np.abs(fine_delay_Ypol_tb - fine_delay_Ypol) > 1) or (np.abs(phase_X_tb - phase_X) > 1) or (np.abs(phase_Y_tb - phase_Y) > 1)):
                            if meta_mismatch < 20:
                                print(f"PYTHON : VC = {vc}, (int,frame,packet) = ({integration},{frame_in_integration},{packet}) coarse = {coarse_delay}, fine X = {fine_delay_Xpol}, fine Y = {fine_delay_Ypol}, phase X = {phase_X}, phase_Y = {phase_Y}")    
                                print(f"    TB : fine X = {fine_delay_Xpol_tb}, fine Y = {fine_delay_Ypol_tb}, phase X = {phase_X_tb}, phase_Y = {phase_Y_tb}")
                            meta_mismatch += 1
                        else:
                            meta_match += 1
                    else:
                        print(f"No tb data : VC = {vc}, (int,frame,packet) = ({integration},{frame_in_integration},{packet}) coarse = {coarse_delay}, fine X = {fine_delay_Xpol}, fine Y = {fine_delay_Ypol}, phase X = {phase_X}, phase_Y = {phase_Y}")
                
                if sim_fb_valid:
                    # Get the data from the CT1 output from the testbench, and calculate the expected output
                    # from the filterbank
                    fb_in = np.zeros(75*4096, dtype = np.complex128)
                    fb_in_RFI = np.zeros(75*4096, dtype = np.int32)
                    # filterbank output : 64 time samples x 3456 fine channels x 2 polarisations
                    fb_out = np.zeros((64,3456,2), dtype = np.complex128)
                    # Fine delay module output, same shape as the filterbank output
                    fdelay_out = np.zeros((64,3456,2), dtype = np.complex128)
                    # RFI marking : 2 polarisations x 64 time samples
                    RFI_sum = np.zeros((2,64), dtype = np.int64)
                    RFI_mark = np.zeros((2,64), dtype = np.int32) 
                    for pol in range(2):
                        for packet in range(75):
                            for sample in range(4096):
                                Xre = data_data[integration_offset,frame_in_integration,packet,vc,pol*2 + 0,sample]
                                Xim = data_data[integration_offset,frame_in_integration,packet,vc,pol*2 + 1,sample]
                                if ((Xre == -32768) or (Xim == -32768)):
                                    fb_in[packet*4096 + sample] = 0
                                    fb_in_RFI[packet*4096 + sample] = 1
                                else:
                                    fb_in[packet*4096 + sample] = Xre + 1j * Xim
                                    fb_in_RFI[packet*4096 + sample] = 0
                        
                        fb_out[:,:,pol] = fb.filter(fb_in, time_steps=64, derotate=False, preload_zeros=0, saturate=False, fft_scale=8192)
                        
                        #print(f"Sim filterbank input vc = {vc}")
                        #print(fb_in[0:20])
                        #print(f"Sim filterbank output vc = {vc}")
                        #print(fb_out[0,0:20,0])
                        
                        # RFI calculation
                        for fb_pkt_out in range(64): # 64 output packets from the filterbank
                            fb_out96x512 = np.reshape(fb_in_RFI[fb_pkt_out * 4096 : (fb_pkt_out * 4096 + 12*4096)],(96,512))
                            fb_out512x96_RFI = fb_out96x512.T
                            RFI_sum[pol,fb_pkt_out] = np.sum(fb_out512x96_RFI * RFI_analysis)
                            
                            if (vc == 0) and (fb_pkt_out == 0):
                                print('asdfasd')
                                print(fb_in[0:10])
                                print("rfi info : ")
                                print(f"{np.sum(fb_out512x96_RFI,0)}")
                                print(f"fb_pkt_out = {fb_pkt_out}, pol = {pol}, RFI_sum = {RFI_sum[pol,fb_pkt_out]}")
                            
                            if ((RFI_thresholds[vc] < 4294967295) and (RFI_sum[pol, fb_pkt_out] > RFI_thresholds[vc])):
                                RFI_mark[pol, fb_pkt_out] = 1
                    for fb_pkt_out in range(64):                        
                        # Apply the fine delay
                        # Get the fine delay from the firmware meta data 
                        # Note the meta data has been checked against the python version already
                        meta_pkt = fb_pkt_out + 11  # +11 to drop meta data for the preload packets
                        fine_delay_Xpol_tb = meta_data[integration_offset, frame_in_integration, meta_pkt, vc, 0]
                        phase_X_tb = meta_data[integration_offset, frame_in_integration, meta_pkt, vc, 1]
                        fine_delay_Ypol_tb = meta_data[integration_offset, frame_in_integration, meta_pkt, vc, 2]
                        phase_Y_tb = meta_data[integration_offset, frame_in_integration, meta_pkt, vc, 3]
                        
                        # Apply the fine delay to the filterbank output
                        for fine_freq in range(3456):
                            xpol = (1/128) * fb_out[fb_pkt_out, fine_freq, 0] * np.exp(-1j * 2 * np.pi * (1/(2**32)) * (phase_X_tb + 2*fine_delay_Xpol_tb * (fine_freq-1728)/2048))
                            ypol = (1/128) * fb_out[fb_pkt_out, fine_freq, 1] * np.exp(-1j * 2 * np.pi * (1/(2**32)) * (phase_Y_tb + 2*fine_delay_Ypol_tb * (fine_freq-1728)/2048))
                            # Mark out of range values as RFI
                            if (np.real(xpol) > 127) or (np.real(xpol) < -127):
                                xpol_re = -128
                            else:
                                xpol_re = np.real(xpol)
                            if (np.imag(xpol) > 127) or (np.imag(xpol) < -127):
                                xpol_im = -128
                            else:
                                xpol_im = np.imag(xpol)
                                
                            if (np.real(ypol) > 127) or (np.real(ypol) < -127):
                                ypol_re = -128
                            else:
                                ypol_re = np.real(ypol)
                            if (np.imag(ypol) > 127) or (np.imag(ypol) < -127):
                                ypol_im = -128
                            else:
                                ypol_im = np.imag(ypol)
                            
                            fdelay_out[fb_pkt_out, fine_freq, 0] = xpol_re + 1j * xpol_im
                            fdelay_out[fb_pkt_out, fine_freq, 1] = ypol_re + 1j * ypol_im
                        
                        # Replace RFI marked values with -128
                        if ((RFI_mark[0, fb_pkt_out] == 1) or (RFI_mark[1, fb_pkt_out] == 1)):
                            for fine_freq in range(3456):
                                fdelay_out[fb_pkt_out, fine_freq, 0] = -128 - 1j * 128
                                fdelay_out[fb_pkt_out, fine_freq, 1] = -128 - 1j * 128
                    
                        # Compare with the simulation output
                        # sim_fb_data has dimensions (integration, frame, packet, virtual_channel, component, fine_channel)
                        #  Note 4 "components" : (H pol re, H pol im, V pol re, V pol im)
                        
                        for fine_freq in range(3456):
                            Xre = sim_fb_data[integration_offset, frame_in_integration, fb_pkt_out, vc, 0, fine_freq]
                            Xim = sim_fb_data[integration_offset, frame_in_integration, fb_pkt_out, vc, 1, fine_freq]
                            Yre = sim_fb_data[integration_offset, frame_in_integration, fb_pkt_out, vc, 2, fine_freq]
                            Yim = sim_fb_data[integration_offset, frame_in_integration, fb_pkt_out, vc, 3, fine_freq]
                            p_Xre = np.real(fdelay_out[fb_pkt_out, fine_freq, 0])
                            p_Xim = np.imag(fdelay_out[fb_pkt_out, fine_freq, 0])
                            p_Yre = np.real(fdelay_out[fb_pkt_out, fine_freq, 1])
                            p_Yim = np.imag(fdelay_out[fb_pkt_out, fine_freq, 1])
                            
                            Emax = np.max([rfi_diff(Xre,p_Xre), rfi_diff(Xim,p_Xim), rfi_diff(Yre,p_Yre), rfi_diff(Yim,p_Yim)])
                            if (Emax > 2):
                                fd_mismatch += 1
                                if (fd_mismatch < 20):
                                    print(f"fine delay output mismatch at integration {integration}, frame {frame_in_integration}, packet {fb_pkt_out}, vc {vc}, fine frequency {fine_freq}")
                                    print(f"  Expected ({p_Xre} + 1i * {p_Xim}, {p_Yre} + 1i * {p_Yim}), Simulation ({Xre} + 1i * {Xim}, {Yre} + 1i * {Yim})")
                            else:
                                fd_match += 1
                                                        
    if tb_valid:
        print(f"checked {sim_frames} frames against simulation")
        print(f"    data sample mismatch = {data_mismatch}, data samples matched = {data_match} ")
        print(f"    meta data mismatch = {meta_mismatch}, meta data matched = {meta_match}")
    if sim_fb_valid:
        print(f"    fine delay output mismatch = {fd_mismatch}, match count = {fd_match}")

if __name__ == "__main__":
    main()